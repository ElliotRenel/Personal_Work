# PUT YOUR CODE IN THIS FILE!

.pos 0x500
library:

########## HEAPADDR ##########

# void * heapaddr()
#
# This function returns the base heap address, as defined
# in memory.ys by the heap tag.

heapaddr:
    irmovl 0x300,%eax
    ret

########## HEAPINIT ##########

# long heapinit(long size)
#
# This function initializes the heap with a single free block of
# a given size (in bytes). This size must not exceed the heap limit
# defined by "heaplimit" tag in memory.ys.
# It returns 1 on success, and 0 on failure.

heapinit:    mrmovl 4(%esp),%ecx 
    irmovl 0x1F4, %edx
    irmovl 1,%eax
    subl %ecx, %edx
    jl mem_fail
    irmovl 0x30C,%edx
    rmmovl %ecx, -12(%edx)     
    irmovl 1, %ecx
    rmmovl %ecx, -8(%edx)       
    irmovl 0, %ecx
    rmmovl %ecx, -4(%edx)
    ret
mem_fail:    isubl 1,%eax
    ret

########## NUMBLOCKS ##########

# long numblocks()
#
# This function returns the total number of blocks in heap.

numblocks:    irmovl 0,%eax
    irmovl 0x30C, %edx
nbstart:    iaddl 1,%eax
    mrmovl -4(%edx),%ebx
    andl %ebx,%ebx
    je nbend
    rrmovl %ebx,%edx
    jmp nbstart
nbend:    ret

########## HEAPSIZE ##########

# long heapsize()
#
# This function returns the total heap size (in bytes), including
# all blocks (with both data and metadata).

heapsize:    irmovl 0,%eax
    irmovl 0x30C, %edx
hsstart:    mrmovl -12(%edx), %ecx
    addl %ecx, %eax
    iaddl 12,%eax
    mrmovl -4(%edx),%ebx
    andl %ebx,%ebx
    je hsend
    rrmovl %ebx,%edx
    jmp hsstart
hsend:    ret

########## HEAPUSAGE ##########

# long heapusage()
#
# This function returns the heap usage (in bytes), defined as
# the sum of all data blocks used (without metadata).

heapusage:    irmovl 0,%eax
    irmovl 0x30C, %edx 
hustart:    mrmovl -8(%edx),%ecx
    isubl 1,%ecx
    jle huskip
    mrmovl -12(%edx),%ecx 
    addl %ecx, %eax
huskip:    mrmovl -4(%edx),%ebx
    andl %ebx, %ebx 
    je huend
    rrmovl %ebx, %edx
    jmp hustart
huend:    ret

########## BLOCKADDR ##########

# void* blockaddr(long k)
#
# This function returns the address of data in the k-th block.
# The block index k must be in range: k >= 0 && k < numblocks().
# It returns NULL in case of error.

blockaddr:  mrmovl 4(%esp),%ecx
    andl %ecx,%ecx
    jl baerror
    irmovl 0x30C, %eax
kblock: mrmovl -4(%eax),%ebx
    isubl 1,%ecx
    jl baend
    rrmovl %ebx, %eax
    andl %eax, %eax
    je baerror
    jmp kblock
baend:  ret
baerror:  irmovl 0x0,%eax
    jmp baend

########## BLOCKSIZE ##########

# long blocksize(long k)
#
# This function returns the actual data size (in bytes) of the k-th block.
# The size of metadata are not taken into account.
# The block index k must be in range: k >= 0 && k < numblocks().
# It returns 0 in case of error.

blocksize:  mrmovl 4(%esp),%ecx
    andl %ecx,%ecx
    jl bserror
    irmovl 0x30C, %esi
kblock2: mrmovl -4(%esi),%ebx
    isubl 1,%ecx
    jl bsfound 
    rrmovl %ebx, %esi
    andl %esi, %esi
    je bserror
    jmp kblock2
bsfound: mrmovl -12(%esi),%eax
bsend:  ret
bserror:  irmovl 0,%eax
    jmp bsend

########## BLOCKFLAG ##########

# long blockflag(long k)
#
# This function returns the flag of the k-th block.
# The block index k must be in range: k >= 0 && k < numblocks().
# It returns 0 in case of error.

blockflag:  mrmovl 4(%esp),%ecx
    andl %ecx,%ecx
    jl bferror
    irmovl 0x30C, %esi
kblock3: mrmovl -4(%esi),%ebx
    isubl 1,%ecx
    jl bffound 
    rrmovl %ebx, %esi
    andl %esi, %esi
    je bferror
    jmp kblock3
bffound: mrmovl -8(%esi),%eax
bfend:  ret
bferror:  irmovl 0,%eax
    jmp bfend


# EOF
