# PUT YOUR CODE IN THIS FILE!

.pos 0x500
library:

########## HEAPADDR ##########

# void * heapaddr()
#
# This function returns the base heap address, as defined
# in memory.ys by the heap tag.

heapaddr:
    irmovl 768,%eax
    ret

########## HEAPINIT ##########

# long heapinit(long size)
#
# This function initializes the heap with a single free block of
# a given size (in bytes). This size must not exceed the heap limit
# defined by "heaplimit" tag in memory.ys.
# It returns 1 on success, and 0 on failure.

heapinit:
    
    ret

########## NUMBLOCKS ##########

# long numblocks()
#
# This function returns the total number of blocks in heap.

numblocks:

    ### PUT YOUR CODE HERE ###

    ret

########## HEAPSIZE ##########

# long heapsize()
#
# This function returns the total heap size (in bytes), including
# all blocks (with both data and metadata).

heapsize:

    ### PUT YOUR CODE HERE ###

    ret

########## HEAPUSAGE ##########

# long heapusage()
#
# This function returns the heap usage (in bytes), defined as
# the sum of all data blocks used (without metadata).

heapusage:

    ### PUT YOUR CODE HERE ###

    ret

########## BLOCKADDR ##########

# void* blockaddr(long k)
#
# This function returns the address of data in the k-th block.
# The block index k must be in range: k >= 0 && k < numblocks().
# It returns NULL in case of error.

blockaddr:

    ### PUT YOUR CODE HERE ###

    ret

########## BLOCKSIZE ##########

# long blocksize(long k)
#
# This function returns the actual data size (in bytes) of the k-th block.
# The size of metadata are not taken into account.
# The block index k must be in range: k >= 0 && k < numblocks().
# It returns 0 in case of error.

blocksize:

    ### PUT YOUR CODE HERE ###

    ret

########## BLOCKFLAG ##########

# long blockflag(long k)
#
# This function returns the flag of the k-th block.
# The block index k must be in range: k >= 0 && k < numblocks().
# It returns 0 in case of error.

blockflag:

    ### PUT YOUR CODE HERE ###

    ret

# EOF
