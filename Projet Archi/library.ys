# PUT YOUR CODE IN THIS FILE!

.pos 0x500
library:

########## HEAPADDR ##########

# void * heapaddr()
#
# This function returns the base heap address, as defined
# in memory.ys by the heap tag.

heapaddr:
    irmovl 0x300,%eax
    ret

########## HEAPINIT ##########

# long heapinit(long size)
#
# This function initializes the heap with a single free block of
# a given size (in bytes). This size must not exceed the heap limit
# defined by "heaplimit" tag in memory.ys.
# It returns 1 on success, and 0 on failure.

heapinit:    mrmovl 4(%esp),%ecx 
    irmovl 0x200, %edx
    irmovl 1,%eax
    subl %ecx, %edx
    jl mem_fail
    irmovl 0x30C,%edx
    isubl 12,%ecx
    rmmovl %ecx, -12(%edx)     
    irmovl 1, %ecx
    rmmovl %ecx, -8(%edx)       
    irmovl 0, %ecx
    rmmovl %ecx, -4(%edx)
    ret
mem_fail:    isubl 1,%eax
    ret

########## NUMBLOCKS ##########

# long numblocks()
#
# This function returns the total number of blocks in heap.

numblocks:    irmovl 0,%eax
    irmovl 0x30C, %edx
nbstart:    iaddl 1,%eax
    mrmovl -4(%edx),%ebx
    andl %ebx,%ebx
    je nbend
    rrmovl %ebx,%edx
    jmp nbstart
nbend:    ret

########## HEAPSIZE ##########

# long heapsize()
#
# This function returns the total heap size (in bytes), including
# all blocks (with both data and metadata).

heapsize:    irmovl 0,%eax
    irmovl 0x30C, %edx
hsstart:    mrmovl -12(%edx), %ecx
    addl %ecx, %eax
    iaddl 12,%eax
    mrmovl -4(%edx),%ebx
    andl %ebx,%ebx
    je hsend
    rrmovl %ebx,%edx
    jmp hsstart
hsend:    ret

########## HEAPUSAGE ##########

# long heapusage()
#
# This function returns the heap usage (in bytes), defined as
# the sum of all data blocks used (without metadata).

heapusage:    irmovl 0,%eax
    irmovl 0x30C, %edx 
hustart:    mrmovl -8(%edx),%ecx
    isubl 1,%ecx
    jle huskip
    mrmovl -12(%edx),%ecx 
    addl %ecx, %eax
huskip:    mrmovl -4(%edx),%ebx
    andl %ebx, %ebx 
    je huend
    rrmovl %ebx, %edx
    jmp hustart
huend:    ret

########## BLOCKADDR ##########

# void* blockaddr(long k)
#
# This function returns the address of data in the k-th block.
# The block index k must be in range: k >= 0 && k < numblocks().
# It returns NULL in case of error.

blockaddr:  mrmovl 4(%esp),%ecx
    andl %ecx,%ecx
    jl baerror
    irmovl 0x30C, %eax
kblock: mrmovl -4(%eax),%ebx
    isubl 1,%ecx
    jl baend
    rrmovl %ebx, %eax
    andl %eax, %eax
    je baerror
    jmp kblock
baend:  ret
baerror:  irmovl 0x0,%eax
    jmp baend

########## BLOCKSIZE ##########

# long blocksize(long k)
#
# This function returns the actual data size (in bytes) of the k-th block.
# The size of metadata are not taken into account.
# The block index k must be in range: k >= 0 && k < numblocks().
# It returns 0 in case of error.

blocksize:  mrmovl 4(%esp),%ecx
    andl %ecx,%ecx
    jl bserror
    irmovl 0x30C, %esi
kblock2: mrmovl -4(%esi),%ebx
    isubl 1,%ecx
    jl bsfound 
    rrmovl %ebx, %esi
    andl %esi, %esi
    je bserror
    jmp kblock2
bsfound: mrmovl -12(%esi),%eax
bsend:  ret
bserror:  irmovl 0,%eax
    jmp bsend

########## BLOCKFLAG ##########

# long blockflag(long k)
#
# This function returns the flag of the k-th block.
# The block index k must be in range: k >= 0 && k < numblocks().
# It returns 0 in case of error.

blockflag:  mrmovl 4(%esp),%ecx
    andl %ecx,%ecx
    jl bferror
    irmovl 0x30C, %esi
kblock3: mrmovl -4(%esi),%ebx
    isubl 1,%ecx
    jl bffound 
    rrmovl %ebx, %esi
    andl %esi, %esi
    je bferror
    jmp kblock3
bffound: mrmovl -8(%esi),%eax
bfend:  ret
bferror:  irmovl 0,%eax
    jmp bfend


########## LOOKUP ##########

# void * lookup(long size)
#
# This function lookups in heap for the first free block with enough memory,
# i.e. the asked "size" is lower or equal to the block data size.
# And it returns the data address of the block found (or NULL if no blocks were found).
# If asked "size" is 0, it returns the data address of the first free block.

lookup:

    ### PUT YOUR CODE HERE ###

    ret

########## SPLIT ##########

# void* split(void* blkaddr, long size)
#
# This function splits a block "b0" (at data address "blkaddr") in two adajacent sub-blocks
# "b1" (at same place as "b0") and "b2", such that these blocks are correctly linked in heap.
# The first block "b1" will contain "size" bytes of data, while the second block "b2" will use
# the remaining space (including its metadata). Both block flags are set to free (1). It returns
# the data address of the first block "b1" or NULL if any error occurs. Especially, if there is
# not enough space to create the second block (i.e. remaining space < 12 bytes).

split:

    ### PUT YOUR CODE HERE ###

    ret


########## MALLOC ##########

# void* malloc(long size)
#
# This function allocates "size" bytes in heap. First, it lookups for a free block "b0"
# with enough memory(for both data and metadata). If "b0" is large enough, it will split
# it in a used block "b1" (at same place as "b0") with the asked size and a free block "b2"
# with remaining space. Else, if "b2" cannot be created, then "b1" will take up all the
# space of "b0", and its returned size may be greater or equal to asked size.
# It returns the data address of the new allocated block "b1" and sets its flag to used (2).
# If not enough memory is available in heap (or if any errors occur), NULL is returned.

malloc:

    ### PUT YOUR CODE HERE ###

    ret


# EOF
